//! Rust struct generator

use crate::ast::{FieldType, Schema, TypeDef};
use crate::error::{AlchemistError, Result};
use crate::generators::{CodeGenerator, GeneratorOptions};
use crate::utils::to_snake_case;

/// Rust struct generator
pub struct RustGenerator {
    options: GeneratorOptions,
}

impl RustGenerator {
    /// Create a new Rust generator with the given options
    pub fn new(options: GeneratorOptions) -> Self {
        Self { options }
    }

    /// Generate a Rust struct from a type definition
    fn generate_struct(&self, type_def: &TypeDef) -> String {
        let mut output = String::new();

        // Add documentation comment if present
        if let Some(doc) = &type_def.doc {
            output.push_str(&format!("/// {}\n", doc));
        }

        // Add derive macros
        if !self.options.derive_macros.is_empty() {
            output.push_str(&format!(
                "#[derive({})]\n",
                self.options.derive_macros.join(", ")
            ));
        }

        // Struct declaration
        output.push_str(&format!("pub struct {} {{\n", type_def.name));

        // Generate fields
        for field in &type_def.fields {
            // Add field documentation if present
            if let Some(doc) = &field.doc {
                output.push_str(&format!("    /// {}\n", doc));
            }

            // Add serde rename if needed
            let original_name = &field.name;
            let code_name = field.code_name();
            if original_name != code_name {
                output.push_str(&format!("    #[serde(rename = \"{}\")]\n", original_name));
            }

            let visibility = if self.options.public_fields {
                "pub "
            } else {
                ""
            };
            let rust_type = self.field_type_to_rust(&field.field_type, field.optional);

            output.push_str(&format!(
                "    {}{}: {},\n",
                visibility,
                to_snake_case(code_name),
                rust_type
            ));
        }

        output.push_str("}\n");
        output
    }

    /// Convert AST FieldType to Rust type string
    fn field_type_to_rust(&self, field_type: &FieldType, optional: bool) -> String {
        let base_type = match field_type {
            FieldType::String => "String".to_string(),
            FieldType::Integer => "i64".to_string(),
            FieldType::Float => "f64".to_string(),
            FieldType::Boolean => "bool".to_string(),
            FieldType::Null => "()".to_string(),
            FieldType::Array(inner) => {
                format!("Vec<{}>", self.field_type_to_rust(inner, false))
            }
            FieldType::Optional(inner) => {
                format!("Option<{}>", self.field_type_to_rust(inner, false))
            }
            FieldType::Reference(name) => name.clone(),
            FieldType::Union(types) => {
                // For union types, we'd need to generate an enum
                // For now, use serde_json::Value as a fallback
                if types.len() == 2 && types.iter().any(|t| matches!(t, FieldType::Null)) {
                    // Handle nullable types
                    let non_null = types
                        .iter()
                        .find(|t| !matches!(t, FieldType::Null))
                        .unwrap();
                    format!("Option<{}>", self.field_type_to_rust(non_null, false))
                } else {
                    "serde_json::Value".to_string()
                }
            }
            FieldType::Any => "serde_json::Value".to_string(),
            FieldType::Map(key, value) => {
                format!(
                    "std::collections::HashMap<{}, {}>",
                    self.field_type_to_rust(key, false),
                    self.field_type_to_rust(value, false)
                )
            }
        };

        if optional && !matches!(field_type, FieldType::Optional(_)) {
            format!("Option<{}>", base_type)
        } else {
            base_type
        }
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&self, schema: &Schema) -> Result<String> {
        if schema.types.is_empty() {
            return Err(AlchemistError::GenerationError(
                "Schema has no types to generate".to_string(),
            ));
        }

        let mut output = String::new();

        // Add header comment
        output.push_str("// Generated by Alchemist\n");
        output.push_str("// Do not edit manually\n\n");

        // Add common imports
        output.push_str("use serde::{Deserialize, Serialize};\n");
        output.push_str("use std::collections::HashMap;\n\n");

        // Generate all type definitions (in reverse order so nested types come first)
        for type_def in schema.types.iter().rev() {
            output.push_str(&self.generate_struct(type_def));
            output.push('\n');
        }

        Ok(output.trim_end().to_string() + "\n")
    }

    fn file_extension(&self) -> &'static str {
        "rs"
    }

    fn name(&self) -> &'static str {
        "Rust"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Field;

    #[test]
    fn test_generate_simple_struct() {
        let mut schema = Schema::new("User");
        let mut type_def = TypeDef::new("User");
        type_def.add_field(Field::new("name", FieldType::String));
        type_def.add_field(Field::new("age", FieldType::Integer));
        schema.add_type(type_def);

        let generator = RustGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("pub struct User {"));
        assert!(output.contains("pub name: String,"));
        assert!(output.contains("pub age: i64,"));
    }
}
