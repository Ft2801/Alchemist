//! TypeScript interface generator

use crate::ast::{FieldType, Schema, TypeDef};
use crate::error::{AlchemistError, Result};
use crate::generators::{CodeGenerator, GeneratorOptions};

/// TypeScript interface generator
pub struct TypeScriptGenerator {
    options: GeneratorOptions,
}

impl TypeScriptGenerator {
    /// Create a new TypeScript generator with the given options
    pub fn new(options: GeneratorOptions) -> Self {
        Self { options }
    }

    /// Generate a TypeScript interface from a type definition
    fn generate_interface(&self, type_def: &TypeDef) -> String {
        let mut output = String::new();

        // Add documentation comment if present
        if let Some(doc) = &type_def.doc {
            output.push_str(&format!("/**\n * {}\n */\n", doc));
        }

        // Interface declaration
        output.push_str(&format!("export interface {} {{\n", type_def.name));

        // Generate fields
        for field in &type_def.fields {
            // Add field documentation if present
            if let Some(doc) = &field.doc {
                output.push_str(&format!("  /** {} */\n", doc));
            }

            let readonly = if self.options.readonly {
                "readonly "
            } else {
                ""
            };
            let optional = if field.optional || self.options.optional_fields {
                "?"
            } else {
                ""
            };
            let field_name = field.code_name();
            let ts_type = self.field_type_to_typescript(&field.field_type);

            output.push_str(&format!(
                "  {}{}{}: {};\n",
                readonly, field_name, optional, ts_type
            ));
        }

        output.push_str("}\n");
        output
    }

    /// Convert AST FieldType to TypeScript type string
    fn field_type_to_typescript(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "string".to_string(),
            FieldType::Integer | FieldType::Float => "number".to_string(),
            FieldType::Boolean => "boolean".to_string(),
            FieldType::Null => "null".to_string(),
            FieldType::Array(inner) => {
                format!("{}[]", self.field_type_to_typescript(inner))
            }
            FieldType::Optional(inner) => {
                format!("{} | undefined", self.field_type_to_typescript(inner))
            }
            FieldType::Reference(name) => name.clone(),
            FieldType::Union(types) => types
                .iter()
                .map(|t| self.field_type_to_typescript(t))
                .collect::<Vec<_>>()
                .join(" | "),
            FieldType::Any => "unknown".to_string(),
            FieldType::Map(key, value) => {
                format!(
                    "Record<{}, {}>",
                    self.field_type_to_typescript(key),
                    self.field_type_to_typescript(value)
                )
            }
        }
    }
}

impl CodeGenerator for TypeScriptGenerator {
    fn generate(&self, schema: &Schema) -> Result<String> {
        if schema.types.is_empty() {
            return Err(AlchemistError::GenerationError(
                "Schema has no types to generate".to_string(),
            ));
        }

        let mut output = String::new();

        // Add header comment
        output.push_str("// Generated by Alchemist\n");
        output.push_str("// Do not edit manually\n\n");

        // Generate all type definitions (in reverse order so nested types come first)
        for type_def in schema.types.iter().rev() {
            output.push_str(&self.generate_interface(type_def));
            output.push('\n');
        }

        Ok(output.trim_end().to_string() + "\n")
    }

    fn file_extension(&self) -> &'static str {
        "ts"
    }

    fn name(&self) -> &'static str {
        "TypeScript"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Field;

    #[test]
    fn test_generate_simple_interface() {
        let mut schema = Schema::new("User");
        let mut type_def = TypeDef::new("User");
        type_def.add_field(Field::new("name", FieldType::String));
        type_def.add_field(Field::new("age", FieldType::Integer));
        type_def.add_field(Field::new("active", FieldType::Boolean));
        schema.add_type(type_def);

        let generator = TypeScriptGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("export interface User {"));
        assert!(output.contains("name: string;"));
        assert!(output.contains("age: number;"));
        assert!(output.contains("active: boolean;"));
    }

    #[test]
    fn test_generate_with_readonly() {
        let mut schema = Schema::new("Config");
        let mut type_def = TypeDef::new("Config");
        type_def.add_field(Field::new("version", FieldType::String));
        schema.add_type(type_def);

        let options = GeneratorOptions {
            readonly: true,
            ..Default::default()
        };
        let generator = TypeScriptGenerator::new(options);
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("readonly version: string;"));
    }

    #[test]
    fn test_generate_with_optional_fields() {
        let mut schema = Schema::new("Config");
        let mut type_def = TypeDef::new("Config");
        type_def.add_field(Field::new("name", FieldType::String).optional());
        schema.add_type(type_def);

        let generator = TypeScriptGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("name?: string;"));
    }

    #[test]
    fn test_generate_array_type() {
        let mut schema = Schema::new("Data");
        let mut type_def = TypeDef::new("Data");
        type_def.add_field(Field::new(
            "items",
            FieldType::Array(Box::new(FieldType::String)),
        ));
        schema.add_type(type_def);

        let generator = TypeScriptGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("items: string[];"));
    }

    #[test]
    fn test_generate_nested_type() {
        let mut schema = Schema::new("Root");

        let mut address = TypeDef::new("Address");
        address.add_field(Field::new("street", FieldType::String));
        address.add_field(Field::new("city", FieldType::String));
        schema.add_type(address);

        let mut root = TypeDef::new("Root");
        root.add_field(Field::new("name", FieldType::String));
        root.add_field(Field::new(
            "address",
            FieldType::Reference("Address".to_string()),
        ));
        schema.add_type(root);

        let generator = TypeScriptGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("export interface Address {"));
        assert!(output.contains("export interface Root {"));
        assert!(output.contains("address: Address;"));
    }
}
