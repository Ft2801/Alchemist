//! Zod schema generator

use crate::ast::{FieldType, Schema, TypeDef};
use crate::error::{AlchemistError, Result};
use crate::generators::{CodeGenerator, GeneratorOptions};

/// Zod schema generator
pub struct ZodGenerator {
    options: GeneratorOptions,
}

impl ZodGenerator {
    /// Create a new Zod generator with the given options
    pub fn new(options: GeneratorOptions) -> Self {
        Self { options }
    }

    /// Generate a Zod schema from a type definition
    fn generate_schema(&self, type_def: &TypeDef) -> String {
        let mut output = String::new();

        // Add documentation comment if present
        if let Some(doc) = &type_def.doc {
            output.push_str(&format!("/**\n * {}\n */\n", doc));
        }

        // Schema declaration
        output.push_str(&format!(
            "export const {}Schema = z.object({{\n",
            type_def.name
        ));

        // Generate fields
        for field in &type_def.fields {
            let field_name = field.code_name();
            let zod_type = self.field_type_to_zod(&field.field_type);

            let final_type = if field.optional || self.options.optional_fields {
                format!("{}.optional()", zod_type)
            } else {
                zod_type
            };

            output.push_str(&format!("  {}: {},\n", field_name, final_type));
        }

        output.push_str("});\n\n");

        // Generate inferred type
        output.push_str(&format!(
            "export type {} = z.infer<typeof {}Schema>;\n",
            type_def.name, type_def.name
        ));

        output
    }

    /// Convert AST FieldType to Zod type string
    fn field_type_to_zod(&self, field_type: &FieldType) -> String {
        match field_type {
            FieldType::String => "z.string()".to_string(),
            FieldType::Integer => "z.number().int()".to_string(),
            FieldType::Float => "z.number()".to_string(),
            FieldType::Boolean => "z.boolean()".to_string(),
            FieldType::Null => "z.null()".to_string(),
            FieldType::Array(inner) => {
                format!("z.array({})", self.field_type_to_zod(inner))
            }
            FieldType::Optional(inner) => {
                format!("{}.optional()", self.field_type_to_zod(inner))
            }
            FieldType::Reference(name) => format!("{}Schema", name),
            FieldType::Union(types) => {
                let types_str = types
                    .iter()
                    .map(|t| self.field_type_to_zod(t))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("z.union([{}])", types_str)
            }
            FieldType::Any => "z.unknown()".to_string(),
            FieldType::Map(key, value) => {
                format!(
                    "z.record({}, {})",
                    self.field_type_to_zod(key),
                    self.field_type_to_zod(value)
                )
            }
        }
    }
}

impl CodeGenerator for ZodGenerator {
    fn generate(&self, schema: &Schema) -> Result<String> {
        if schema.types.is_empty() {
            return Err(AlchemistError::GenerationError(
                "Schema has no types to generate".to_string(),
            ));
        }

        let mut output = String::new();

        // Add header comment
        output.push_str("// Generated by Alchemist\n");
        output.push_str("// Do not edit manually\n\n");

        // Add zod import
        output.push_str("import { z } from 'zod';\n\n");

        // Generate all type definitions (in reverse order so nested types come first)
        for type_def in schema.types.iter().rev() {
            output.push_str(&self.generate_schema(type_def));
            output.push('\n');
        }

        Ok(output.trim_end().to_string() + "\n")
    }

    fn file_extension(&self) -> &'static str {
        "ts"
    }

    fn name(&self) -> &'static str {
        "Zod"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Field;

    #[test]
    fn test_generate_simple_schema() {
        let mut schema = Schema::new("User");
        let mut type_def = TypeDef::new("User");
        type_def.add_field(Field::new("name", FieldType::String));
        type_def.add_field(Field::new("age", FieldType::Integer));
        schema.add_type(type_def);

        let generator = ZodGenerator::new(GeneratorOptions::default());
        let output = generator.generate(&schema).unwrap();

        assert!(output.contains("export const UserSchema = z.object({"));
        assert!(output.contains("name: z.string(),"));
        assert!(output.contains("age: z.number().int(),"));
        assert!(output.contains("export type User = z.infer<typeof UserSchema>;"));
    }
}
